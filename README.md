### 동시성 제어 방식 보고서

## 동시성 제어란

동시성 제어는 다수의 사용자 사이에서 동시에 작용하는 다중 트랜잭션의 상호 간섭 작용으로부터 데이터베이스를 보호하는 것을 의미합니다. 데이터베이스 접근을 동시에 모두 허용할 경우, 데이터베이스의 일관성과 무결성이 깨질 수 있습니다. 따라서 동시성 제어는 병행 제어라고도 불리며, 한 번에 들어온 여러 트랜잭션을 직렬화하는 수행을 보장합니다.

동시성 제어 기법은 여러 가지가 있으며, 주요 기법으로는 로킹 기법, 타임스탬프 기법, 적합성 검증(낙관적 검증), 그리고 다중버전 동시성 제어 기법이 있습니다.

- **로킹 기법(Locking Method)**: 트랜잭션이 사용하는 데이터 자원에 대해 상호 배제를 제공하는 기법입니다. 상호 배제란 트랜잭션이 데이터 항목에 잠금(Lock)을 설정한 후, 해당 트랜잭션이 해제(UnLock)할 때까지 데이터를 독점적으로 사용할 수 있는 것을 의미합니다.
  - **공유 Lock(Shared Lock)**: 공유 잠금한 트랜잭션은 데이터 항목에 대해 읽기만 가능하고, 다른 트랜잭션도 읽기만 수행할 수 있습니다.
  - **전용 Lock(Exclusive Lock)**: 전용 잠금한 트랜잭션은 데이터 항목에 대해 읽기와 기록 모두 가능하지만, 다른 트랜잭션은 읽기와 기록 모두 할 수 없습니다.

로킹 기법의 허점은 락을 걸거나 해제하는 시점에 제한을 두지 않으면, 두 개의 트랜잭션이 동시에 실행될 때 데이터의 일관성이 깨질 수 있다는 점입니다. 이를 해결하기 위해 2단계 로킹(2 Phase Locking) 기법이 사용됩니다. 이로인해 처리 속도가 더욱 느려집니다.

- **블로킹(Blocking) 현상**: 블로킹이란 Lock 간의 경합이 발생하여 특정 트랜잭션 작업을 진행하지 못하고 멈춰 선 상태를 말합니다. 공유 Lock 간에는 서로 특정 데이터에 대해 동시 접근이 가능하기 때문에 블로킹이 발생하지 않지만, 공유 Lock과 전용 Lock 간의 경합에서는 블로킹이 발생할 수 있습니다. 이러한 현상은 애플리케이션 성능에 좋지 않은 영향을 미치므로 블로킹을 최소화해야 합니다.

- **타임스탬프(Time Stamp)**: 트랜잭션의 순서대로 시간 스탬프를 지정하여 동시성 제어의 기준으로 사용되는 개념입니다.

- **적합성 검증(낙관적 검증 기법)**: 트랜잭션이 어떠한 검증도 수행하지 않고, 일단 트랜잭션을 수행한 후 종료할 때 검증을 수행하여 데이터베이스에 반영하는 방법입니다. 만약 트랜잭션의 길이가 길어 장기적으로 진행되었는데 Roll Back 되는 경우 자원 낭비가 발생할 수 있으므로, 동시 사용 빈도가 낮은 시스템에서 주로 사용됩니다.

- **MVCC(다중버전 동시성 제어 기법)**: MVCC는 동시 접근을 허용하는 데이터베이스에서 동시성을 제어하기 위해 사용하는 방법 중 하나입니다. 데이터에 접근하는 사용자는 접근하는 시점의 데이터베이스 snapshot을 읽습니다. 이 snapshot 데이터에 대한 변경이 완료(commit)될 때까지의 변경사항은 다른 데이터베이스 사용자가 볼 수 없습니다. 이후 사용자가 업데이트를 하면 이전 데이터를 덮어쓰는 것이 아니라 새로운 버전의 데이터를 생성합니다. 이렇게 여러 버전의 데이터를 가지며 현재 실행하고 있는 스케줄의 직렬 가능성이 보장되는 적절한 버전을 선택하여 접근하도록 하는 기법이 MVCC입니다.

MVCC 접근 방식은 트랜잭션의 대기 시간이 존재하지 않으므로 빠르게 동작할 수 있습니다. 또한 데이터를 읽기 시작할 때 다른 트랜잭션이 그 데이터를 삭제하거나 수정해도 영향을 받지 않고 조회할 수 있습니다.

## 이번 과제에 사용된 방식은 로킹 기법

이번 과제에서는 로킹과 큐를 이용하여 동시성 제어를 구현했습니다. 그러나 제가 사용하는 Python의 SQLAlchemy를 고려해보면, SQLAlchemy는 다중버전 동시성 제어 기법을 사용하는 것 같습니다. 변경사항이 flush될 때까지는 다른 사용자가 볼 수 없고, commit을 해야 비로소 볼 수 있는 구조입니다. 만약 commit에서 문제가 생긴다면 해당 세션의 변경 내용을 rollback하여 데이터베이스를 안전하게 보호할 수 있습니다. 동시성 제어 기법은 대기 시간이 존재하지 않으므로 빠르게 동작하고 동시성을 효과적으로 제어할 수 있으며, 문제가 발생할 경우 롤백을 통해 안정성을 확보할 수 있어 매우 좋은 방식으로 생각됩니다. 그렇기에 SQLAlchemy도 해당 개념을 이용하는 거 같습니다.

## 결론

동시성 제어는 다른 라이브러리가 처리하겠지라는 안일한 생각에 제대로 생각해 본 적이 없습니다. 이번 과제를 계기로 DB 트랜잭션이 결코 단순한 일이 아니라는 것을 깨달았습니다. 기회가 된다면 이번 과제에서 사용한 로킹 기법이 아닌 다중버전 동시성 제어 기법을 사용하여 다시 구현해보고 서로 성능을 비교해보고 싶습니다.
